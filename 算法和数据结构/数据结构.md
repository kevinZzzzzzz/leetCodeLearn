# 数据结构

### 数组

### 栈stack

栈是一种遵循**后进先出**原则的**有序集合**，栈内两端分别叫做栈顶、栈底，新元素从栈顶加入。旧元素往栈底压。

### 队列queue

队列是遵循**先进先出**原则的一组**有序的项**，在队尾添加新的元素，在顶部移除元素。新添加的元素必须排在队末。

双端队列**deque**一种允许队首和队尾同时操作的特殊队列，常用于储存一系列的撤销操作。

​		击鼓传花，回文检测等算法

### 链表LinkedList

链表存储有序的元素集合，元素在内存中并不是连续放置的，**由一个存储元素本身的节点(value)和一个指向下一个元素的引用指针(next)组成**。

​	链表相对于数组的好处：添加或者移除元素的时候不需要移动其他元素。

​	链表需要使用指针，想访问链表中间的一个元素，需要从表头开始迭代链表直到找到所要找的元素。

​	链表的结构就好比寻宝游戏，手头有一个宝藏线索，这条线索指向下一处地点的指针，并且你还必须从起点开始找。

双向链表doubleLinkedList：普通链表是单向的，有表头**head**，而双向链表，一个链向下一个元素**next**，一个链向上一个元素**prev**，除了表头，还会有表尾表示最后一个元素**tail**。

循环链表circularLinkedList：在原来双线链表的基础上，将tail.next指向链头head

双向循环链表则是在循环链表的基础上链头head.prev指向链尾tail

有序链表是指保持元素有序的链表结构 

### 集合Set

- 无序
- 无重复项

### 字典Map

与Set类似

### 哈希表Hash

数组的问题：

- 数组进行插入操作时，效率是比较低的
- 数组进行查找操作的效率
  - 如果基于索引进行查找效率非常高
  - 基于内容查找，效率不高
- 数组进行删除操作，效率不高

相关概念：

- 哈希化：将大数字转化为数组范围内下标的过程
- 哈希函数：通常我们会**将单词转化为大数字**，大数字在进行哈希化 的代码实现放在一个函数内
- 哈希表：最终将数据插入到这个数组，对整个结构的封装

qa：哈希化后，一旦返回的key发生冲突的时候常见的两种方案？

- 链地址法

  每个数组单元存储的不再是单个数据，而是一个链条，常见的链条是数组和链表

  当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询要寻找的数据

- 开放地址法

## 数

### 二叉树

如果树中的每个节点最多只能有两个字节点，这样的树就称为“二叉树”

二叉树可以为空，若不为空，则它是由根节点和称为其左子节点TL和右子树TR的两个不相交的二叉树组成

二叉树的特性：

- 一个二叉树第i层的最大节点数为：2^(i-1), i>=1;
- 深度为k的二叉树有最大节点总数为：2^k-1, k >= 1;
- 对任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么两者满足关系n0 = n2 + 1

##### 二叉搜索树：BST

性质：

- 非空左子树的所有键值小于其根节点的键值（左路径逐级递减）
- 非空右子树的所有键值大于其根节点的键值（右路径逐级递增）
- 左右子树也满足二叉搜索树

特点：

- 相对较小的值总是保存在左节点上，相对较大的值总保存在有节点上 



### 红黑树

除了符合二叉搜索树的基本规则外，还添加了特性：

- 节点是红色或者黑色
- 根节点是黑色
- 每个叶子节点都是黑色的空节点（NIL节点）
- 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点
- 从任一个节点到其每个叶子的所有路径包含 相同数目的黑色节点



## 图

  图的遍历：需要将图中每个顶点访问一遍，并且不能有重复的访问

有两种算法可以对图进行遍历，这两种算法都需要明确指定第一个被访问的顶点

-   广度优先搜索BFS
- 深度优先搜索DFS

## 大O表示法

粗略描述计算机算法的效率

常见大O的表示形式：常数O(1), 对数O(log(n))、线性O(n)、线性和对数乘积O(nlog(n))、平方O(n^2)、指数O(2^n)

 